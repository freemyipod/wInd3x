package encryptsha1

import (
	"bytes"
	"fmt"
	"time"

	"github.com/golang/glog"
	"github.com/google/gousb"

	"github.com/freemyipod/wInd3x/pkg/app"
	"github.com/freemyipod/wInd3x/pkg/dfu"
	"github.com/freemyipod/wInd3x/pkg/exploit"
	"github.com/freemyipod/wInd3x/pkg/uasm"
)

// Payload creates a payload which encrypts 0x10 bytes from the DFU
// buffer into the DFU buffer using a zero IV and the Global key.
// This is useful for creating custom IMG1s
func Payload(ep exploit.Parameters) ([]byte, error) {
	insns := ep.DisableICache()
	insns = append(insns, ep.AESEncryptSha1()...)
	insns = append(insns, ep.HandlerFooter(ep.DFUBufAddr())...)
	payload := uasm.Program{
		Address: ep.ExecAddr(),
		Listing: insns,
	}

	return payload.Assemble(), nil
}

func Trigger(usb *gousb.Device, ep exploit.Parameters, data []byte) ([]byte, error) {
	if err := dfu.Clean(usb); err != nil {
		return nil, fmt.Errorf("clean failed: %w", err)
	}
	payload, err := Payload(ep)
	if err != nil {
		return nil, fmt.Errorf("failed to generate payload: %w", err)
	}

	dataCopy := make([]byte, 0x10)
	copy(dataCopy, data)
	res, err := exploit.RCE(usb, ep, payload, dataCopy)
	if err != nil {
		return nil, fmt.Errorf("failed to execute encrypt sha1: %w", err)
	}

	return res, nil
}

func Encryptsha1(app *app.App, in []byte) ([]byte, error) {
    if len(in) != 0x10{
        glog.Infof("Found input sha1 hash as 0x%x bytes. This has should be exactly 0x10 bytes long", len(in))
		return nil, fmt.Errorf("Input sha1 hash is wrong size.")
    }
	glog.Infof("Encrypting sha1 hash 0x%x bytes...", len(in))
	w := bytes.NewBuffer(nil)


	tries := 10
	var res []byte
	for {
		data := make([]byte, 0x10)
		copy(data[:0x10], in[:0x10])

		var err error
		res, err = Trigger(app.Usb, app.Ep, data)
		if err == nil {
			break
		}
		if tries < 1 {
			return nil, fmt.Errorf("Encryption failed, and out of retries: %w", err)
		} else {
			glog.Infof("Encryption failed (%v), retrying...", err)
			time.Sleep(100 * time.Millisecond)
			tries -= 1
		}
	}

	sha1aes := res[:0x10]
	if _, err := w.Write(sha1aes); err != nil {
		return nil, fmt.Errorf("write failed: %w", err)
	}

	return w.Bytes(), nil
}
