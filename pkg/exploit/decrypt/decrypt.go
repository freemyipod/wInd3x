package decrypt

import (
	"bytes"
	"fmt"
	"io"
	"log/slog"
	"os"
	"time"

	"github.com/freemyipod/wInd3x/pkg/app"
	"github.com/freemyipod/wInd3x/pkg/devices"
	"github.com/freemyipod/wInd3x/pkg/dfu"
	"github.com/freemyipod/wInd3x/pkg/exploit"
	"github.com/freemyipod/wInd3x/pkg/uasm"
)

// Payload creates a payload which decrypts 0x40 bytes from the DFU
// buffer into the DFU buffer using a zero IV and the Global key.
//
// Note: If using CBC, this means the first block will be junk.
//
// TODO(q3k): fix this by allowing to specify any IV. Didn't have luck
// reconstructing CBC this way so far, though...
func Payload(ep exploit.Parameters) ([]byte, error) {
	insns := ep.DisableICache()
	insns = append(insns, ep.AESCall()...)
	insns = append(insns, ep.HandlerFooter(ep.DFUBufAddr())...)
	payload := uasm.Program{
		Address: ep.ExecAddr(),
		Listing: insns,
	}

	return payload.Assemble(), nil
}

func Trigger(usb devices.Usb, ep exploit.Parameters, data []byte) ([]byte, error) {
	if err := dfu.Clean(usb); err != nil {
		return nil, fmt.Errorf("clean failed: %w", err)
	}
	payload, err := Payload(ep)
	if err != nil {
		return nil, fmt.Errorf("failed to generate payload: %w", err)
	}

	dataCopy := make([]byte, 0x40)
	copy(dataCopy, data)
	res, err := exploit.RCE(usb, ep, payload, dataCopy)
	if err != nil {
		return nil, fmt.Errorf("failed to execute decrypt payload: %w", err)
	}

	return res, nil
}

func Decrypt(app *app.App, in []byte, recoveryPath string) ([]byte, error) {
	slog.Info("Decrypting ...", "len", len(in))
	w := bytes.NewBuffer(nil)

	// Create a temporary file that we can use to continue decryption from
	// after restarting the program.
	var recovery io.WriteCloser
	if recoveryPath != "" {
		st, err := os.Stat(recoveryPath)
		if err == nil {
			slog.Info("Using recovery buffer...", "path", recoveryPath)
			sz := st.Size()
			if (sz % 0x30) != 0 {
				return nil, fmt.Errorf("recovery buffer invalid size (%x)", sz)
			}
			f, err := os.Open(recoveryPath)
			if err != nil {
				return nil, fmt.Errorf("could not open recovery buffer: %w", err)
			}
			if _, err := io.Copy(w, f); err != nil {
				return nil, fmt.Errorf("could not read recovery buffer: %w", err)
			}
			f.Close()
		} else if os.IsNotExist(err) {
			slog.Info("Creating recovery buffer...", "path", recoveryPath)
		} else {
			// This happens on the WASM port, quick hack to work around it...
			slog.Error("Could not access recovery buffer", "error", err)
			goto no_recovery
		}
		recovery, err = os.OpenFile(recoveryPath, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
		if err != nil {
			return nil, fmt.Errorf("could not open recovery buffer for append: %w", err)
		}
	}
no_recovery:

	ix := w.Len()
	for {
		if (ix % 0x300) == 0 {
			slog.Info("Decrypting", "ix", ix, "percent", float64(ix*100)/float64(len(in)))
		}

		// Get plaintext block, pad to 0x30.
		ixe := ix + 0x30
		if ixe > len(in) {
			ixe = len(in)
		}
		b := in[ix:ixe]
		b = append(b, bytes.Repeat([]byte{0}, 0x30-len(b))...)

		tries := 10
		var res []byte
		for {
			data := make([]byte, 0x40)
			// We need to feed the previous 0x10 bytes of ciphertext for...
			// some reason. Unless we're the first block.
			if ix == 0 {
				copy(data[:0x30], b)
			} else {
				copy(data[:0x10], in[ix-0x10:ix])
				copy(data[0x10:0x40], b)
			}

			var err error
			res, err = Trigger(app.Usb, app.Ep, data)
			if err == nil {
				break
			}
			if tries < 1 {
				return nil, fmt.Errorf("decryption failed, and out of retries: %w", err)
			} else {
				slog.Info("Decryption failed, retrying...", "err", err)
				time.Sleep(100 * time.Millisecond)
				tries -= 1
			}
		}

		plaintext := res[0x10:0x40]
		if ix == 0 {
			plaintext = res[0x00:0x30]
		}
		if recovery != nil {
			if _, err := recovery.Write(plaintext); err != nil {
				return nil, fmt.Errorf("write to recovery failed: %w", err)
			}
		}
		if _, err := w.Write(plaintext); err != nil {
			return nil, fmt.Errorf("write failed: %w", err)
		}

		ix += 0x30
		if ix >= len(in) {
			break
		}
	}

	return w.Bytes(), nil
}
